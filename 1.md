## Покажите или опровергните регулярность языка
1)
    2) Язык нерегулярный. Для любого `n` рассмотрим слово `w = b^n a^n`. Тогда `y` содержит только `b`, а значит можем повторять `y` много раз, пока не нарушим условие принадлежности языку.
    4) Язык `{w in {a,b}* | |w|_a = |w|_b}` нерегулярный. Для любого `n` рассмотрим слово `w = a^n b^n`. Тогда `y` содержит только `a`, а значит можем повторять `y` несколько раз и получить слово не из языка. Исходный язык является дополнением к этому, значит он тоже нерегулярный в виду замкнутости класса регулярных относительно дополнения. 
    6) Язык нерегулярный. Рассмотрим слово `w = b^(n+1) a a^n`. Тогда `y` содержит хотя бы одну `b`. Если `y` выкинуть, то получим слово не из языка.
    8) Язык регулярный. Регулярное выражение: `(a*ba*){1,m}a^m`.

2)
    1) Подходят все слова, в которых последний символ в слове встречается хотя бы два раза. Тогда подойдет `(aa*|bb*|(a|b)*(ab|ba)(a|b)*(a|b))`.
    2) `(a a* (\eps | b))*` -- входит пустое слово и слова, которые обязательно начинаются с `a` и не содержат двух подряд идущих `b`.
    3) `e* | f*` -- пустое слово сюда входит, слова из повторения `e` один раз и более входят, для `f` аналогично.

3) Я изучил описание конкретного синтаксиса Клочкова Антона и Суннари Джоуни. 

Фидбек по спецификации Антона:
    
* В спецификации не нашел описание разделителей для операторов (и есть ли они вообще?).

* Не нашел конструкции для `Ignore` statement.  

* Исходя из спецификации, `Expr` нельзя заключать в скобки, а часто возникает желание задать приоритет вычисления.

* Плюсом хочется отметить, что для описания использовалась распространенная нотация, что облегчило чтение. Сама спецификация довольно короткая, ее просто понять.

Фидбек по спецификации Джоуни:

* На мой взгляд, спецификации не хватает формальности. Было бы неплохо выбрать какую-либо из известных нотаций для описания лексики и синтаксиса.

* Есть описание синтаксиса функций и пользовательских типов. Но я не нашел описания синтаксиса операторов и выражений `read`, `write`, `ignore`.
* Не указаны разделители для операторов (если они вообще есть?).

* Плюсом хочется отметить придуманный синтаксический сахар для условного выражения и введение функций и пользовательских типов.
